<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <title>High-Speed Immersive Filter</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    <style>
        html, body { margin: 0; padding: 0; width: 100vw; height: 100vh; background: #000; overflow: hidden; position: fixed; }
        canvas { 
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            object-fit: cover; image-rendering: pixelated; z-index: 1;
        }
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.9); z-index: 100; color: #0f0; font-family: monospace;
        }
        button { background: #0f0; color: #000; border: none; padding: 20px 40px; font-size: 1.5rem; font-weight: bold; border-radius: 50px; }
        #webcam { display: none; }
    </style>
</head>
<body>

    <div id="overlay">
        <div id="load-status">LOADING PYTHON...</div>
        <button id="startBtn" onclick="launchApp()" style="display:none;">START IMMERSIVE FEED</button>
    </div>

    <video id="webcam" autoplay playsinline></video>
    <canvas id="outputCanvas"></canvas>

    <script>
        function launchApp() {
            const doc = document.documentElement;
            if (doc.requestFullscreen) doc.requestFullscreen();
            document.getElementById('overlay').style.display = 'none';
            startCamera();
        }

        async function startCamera() {
            const video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { width: {ideal: 1920}, height: {ideal: 1080}, facingMode: "user" }, 
                audio: false 
            });
            video.srcObject = stream;
        }

        function pythonReady() {
            document.getElementById('load-status').style.display = 'none';
            document.getElementById('startBtn').style.display = 'block';
        }
    </script>

    <script type="py" config='{"packages": ["opencv-python", "numpy"]}'>
        import cv2
        import numpy as np
        import time
        from js import document, window, requestAnimationFrame, pythonReady
        from pyodide.ffi import create_proxy

        pythonReady()
        video = document.getElementById("webcam")
        canvas = document.getElementById("outputCanvas")
        ctx = canvas.getContext("2d")

        def loop(t):
            if video.videoWidth > 0:
                # --- SPEED HACK: INTERNAL DOWNSCALE ---
                # We calculate math on 360p even if input is 1080p
                proc_w = 480 
                proc_h = int(video.videoHeight * (proc_w / video.videoWidth))
                
                if canvas.width != proc_w:
                    canvas.width = proc_w
                    canvas.height = proc_h
                
                ctx.drawImage(video, 0, 0, proc_w, proc_h)
                img_data = ctx.getImageData(0, 0, proc_w, proc_h)
                
                # Fast bridge
                frame = np.frombuffer(img_data.data.to_py(), dtype=np.uint8).reshape((proc_h, proc_w, 4))
                frame = cv2.flip(frame, 1)

                # --- OPTIMIZED PROCESSING ---
                bgr = cv2.cvtColor(frame, cv2.COLOR_RGBA2BGR)
                gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
                
                # Fast Blur (smaller kernel = faster)
                blurred = cv2.medianBlur(gray, 3) 
                
                # Fast Laplacian
                edges = cv2.Laplacian(blurred, cv2.CV_8U, ksize=3)
                
                # Thresholding
                _, thresh = cv2.threshold(edges, 40, 255, cv2.THRESH_BINARY)
                
                # Bitwise Mask (Much faster than full NumPy indexing)
                mask = cv2.bitwise_and(bgr, bgr, mask=thresh)

                # Return to screen
                res_rgba = cv2.cvtColor(mask, cv2.COLOR_BGR2RGBA)
                img_ptr = window.ImageData.new(window.Uint8ClampedArray.new(res_rgba.tobytes()), proc_w, proc_h)
                ctx.putImageData(img_ptr, 0, 0)

            requestAnimationFrame(create_proxy(loop))

        loop(0)
    </script>
</body>
</html>
