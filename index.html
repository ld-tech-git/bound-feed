<script>
    let currentPanel = 'A', isLibReady = false, isRecording = false;
    const video = document.getElementById('webcam'), canvas = document.getElementById('outputCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }), offCanvas = document.createElement('canvas');
    const offCtx = offCanvas.getContext('2d');
    
    let worker, isProcessing = false, currentFacingMode = "user", activeConfig = null;
    let mediaRecorder, recordedChunks = [], frames = 0, lastTime = performance.now();
    
    // HEALTH CHECK VARIABLES
    let lastWorkerResponse = performance.now();
    let lastVideoTime = -1;
    let healthInterval;

    function initWorker() {
        if (worker) worker.terminate();
        worker = new Worker('./worker.js');
        worker.onmessage = (e) => {
            if (e.data === "READY") {
                isLibReady = true;
                document.getElementById('bootBtn').innerText = "BOOT ENGINE";
                document.getElementById('bootBtn').classList.add('ready');
                document.getElementById('status').innerText = "ONLINE";
            } else if (e.data === "PONG") {
                lastWorkerResponse = performance.now(); // Worker is alive
            } else if (e.data === "RECOVER") {
                isProcessing = false;
            } else { 
                ctx.putImageData(e.data, 0, 0); 
                isProcessing = false; 
                frames++; 
                lastWorkerResponse = performance.now(); // Successful frame counts as a response
            }
        };
    }

    function startHealthCheck() {
        if (healthInterval) clearInterval(healthInterval);
        healthInterval = setInterval(() => {
            if (!activeConfig) return;

            const now = performance.now();
            const timeSinceLastResponse = now - lastWorkerResponse;
            const isVideoStalled = (video.currentTime === lastVideoTime);
            lastVideoTime = video.currentTime;

            // If worker hasn't responded in 4s OR video hasn't moved in 4s
            if (timeSinceLastResponse > 4000 || isVideoStalled) {
                console.warn("Health Check Failed: Restarting Media Pipeline...");
                // The Nuclear Reset: Reboot everything
                initWorker(); 
                bootApp(); 
            } else {
                worker.postMessage("PING"); // Check worker pulse
            }
        }, 5000);
    }

    window.onload = () => { initWorker(); };

    // ... switchPanel, toggleFullScreen, toggleRecording remain identical ...

    async function bootApp() {
        if(!isLibReady) return;
        isProcessing = false;
        if (video.srcObject) {
            video.srcObject.getTracks().forEach(track => track.stop());
        }
        activeConfig = {
            panel: currentPanel,
            scale: parseFloat(document.getElementById(currentPanel === 'A' ? 'scaleA' : 'scaleB').value),
            blur: parseInt(document.getElementById(currentPanel === 'A' ? 'blurA' : 'blurB').value),
            sense: parseFloat(document.getElementById(currentPanel === 'A' ? 'senseA' : 'senseB').value),
            k: parseInt(document.getElementById('kSize').value),
            oldCode: (currentPanel === 'B' && document.getElementById('logicB').value === 'old_code')
        };
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { width: { ideal: parseInt(document.getElementById('res').value) }, facingMode: currentFacingMode } 
            });
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                canvas.width = offCanvas.width = Math.floor(video.videoWidth / activeConfig.scale);
                canvas.height = offCanvas.height = Math.floor(video.videoHeight / activeConfig.scale);
                document.getElementById('dashboard').style.display = 'none';
                canvas.style.display = 'block';
                document.getElementById('fsToggle').style.display = 'block';
                startHealthCheck(); // Start monitoring once engine boots
                requestAnimationFrame(processLoop);
            };
        } catch (err) {
            document.getElementById('status').innerText = "CAMERA ERROR";
        }
    }

    function processLoop() {
        if (!isProcessing && video.videoWidth > 0 && activeConfig) {
            isProcessing = true;
            offCtx.drawImage(video, 0, 0, offCanvas.width, offCanvas.height);
            const imgData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height);
            worker.postMessage({ img: imgData, ...activeConfig, isFront: (currentFacingMode === "user") }, [imgData.data.buffer]);
        }
        
        const now = performance.now();
        if (now - lastTime >= 1000) { 
            document.getElementById('fps-tag').innerText = `FPS: ${frames}`; 
            frames = 0; 
            lastTime = now; 
        }
        requestAnimationFrame(processLoop);
    }

    // ... Tap and Touch listeners remain identical ...
</script>
