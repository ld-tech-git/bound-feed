/* ================= DOM BINDS (SAFE) ================= */
const video = document.getElementById('webcam');
const canvas = document.getElementById('outputCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

const offCanvas = document.createElement('canvas');
const offCtx = offCanvas.getContext('2d');

const bootBtn   = document.getElementById('bootBtn');
const status    = document.getElementById('status');
const dashboard = document.getElementById('dashboard');
const fpsTag    = document.getElementById('fps-tag');
const fsToggle  = document.getElementById('fsToggle');
const logicB    = document.getElementById('logicB');
const res       = document.getElementById('res');

/* ================= STATE ================= */
let worker = null;
let isLibReady = false;
let isProcessing = false;
let frameQueue = [];

let currentPanel = 'A';
let currentFacingMode = 'user';
let activeConfig = null;

let frames = 0;
let lastTime = performance.now();
let lastWorkerResponse = performance.now();
let healthInterval = null;

/* ================= WORKER ================= */
function initWorker() {
  try {
    if (worker) worker.terminate();
    worker = new Worker('./worker.js');

    worker.onmessage = e => {
      if (e.data === 'READY') {
        isLibReady = true;
        bootBtn.innerText = 'BOOT ENGINE';
        bootBtn.classList.add('ready');
        status.innerText = 'ONLINE';
        status.style.color = '#0f0';
        return;
      }

      if (e.data === 'PONG') {
        lastWorkerResponse = performance.now();
        return;
      }

      if (e.data === 'RECOVER') {
        isProcessing = false;
        frameQueue.length = 0;
        return;
      }

      ctx.putImageData(e.data, 0, 0);
      frames++;
      isProcessing = false;
      lastWorkerResponse = performance.now();
    };

  } catch (err) {
    console.error('Worker init failed:', err);
  }
}

initWorker();

/* ================= FRAME QUEUE (FIXED) ================= */
function enqueueFrame(img) {
  frameQueue.push(img);

  if (frameQueue.length > 30) {
    frameQueue = frameQueue.slice(-10);
  } else if (frameQueue.length > 10) {
    frameQueue = frameQueue.slice(-5);
  } else if (frameQueue.length > 5) {
    frameQueue = frameQueue.slice(-3);
  }
}

/* ================= MAIN LOOP ================= */
function processLoop() {
  if (
    video.readyState >= 2 &&
    video.videoWidth > 0 &&
    activeConfig &&
    !isProcessing
  ) {
    offCtx.drawImage(video, 0, 0, offCanvas.width, offCanvas.height);
    enqueueFrame(offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height));

    if (frameQueue.length) {
      isProcessing = true;
      const img = frameQueue.pop();
      frameQueue.length = 0;

      worker.postMessage(
        { img, ...activeConfig, isFront: currentFacingMode === 'user' },
        [img.data.buffer]
      );
    }
  }

  const now = performance.now();
  if (now - lastTime >= 1000) {
    fpsTag.innerText = `FPS: ${frames}`;
    frames = 0;
    lastTime = now;
  }

  requestAnimationFrame(processLoop);
}

/* ================= HEALTH CHECK ================= */
function startHealthCheck() {
  if (healthInterval) return;

  healthInterval = setInterval(() => {
    const now = performance.now();
    if (now - lastWorkerResponse > 3000) worker.postMessage('PING');
    if (now - lastWorkerResponse > 7000) initWorker();
  }, 2000);
}

/* ================= BOOT ================= */
async function bootApp() {
  if (!isLibReady) return;

  if (video.srcObject)
    video.srcObject.getTracks().forEach(t => t.stop());

  activeConfig = {
    panel: currentPanel,
    scale: parseFloat(
      document.getElementById(currentPanel === 'A' ? 'scaleA' : 'scaleB').value
    ),
    blur: parseInt(
      document.getElementById(currentPanel === 'A' ? 'blurA' : 'blurB').value
    ),
    sense: parseFloat(
      document.getElementById(currentPanel === 'A' ? 'senseA' : 'senseB').value
    ),
    k: parseInt(document.getElementById('kSize').value),
    oldCode: currentPanel === 'B' && logicB.value === 'old_code'
  };

  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        width: { ideal: parseInt(res.value) },
        facingMode: currentFacingMode
      }
    });

    video.srcObject = stream;

    video.onloadedmetadata = () => {
      canvas.width = offCanvas.width =
        Math.floor(video.videoWidth / activeConfig.scale);
      canvas.height = offCanvas.height =
        Math.floor(video.videoHeight / activeConfig.scale);

      dashboard.style.display = 'none';
      canvas.style.display = 'block';
      fsToggle.style.display = 'block';

      startHealthCheck();
      requestAnimationFrame(processLoop);
    };

  } catch (e) {
    console.error(e);
    status.innerText = 'CAMERA ERROR';
  }
}
